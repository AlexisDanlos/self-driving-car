<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation de Voiture Autonome</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Simulation de Voiture Autonome</h2>
        <p>Circuit avec obstacles identifiables</p>
        <p>La voiture rouge ralentit et évite les obstacles</p>
        <p id="speedInfo">Vitesse actuelle: 100%</p>
        <p id="obstacleStatus"></p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script>
        // Configuration
        const config = {
            roadWidth: 12,
            carSpeed: 0.5,
            safeDistance: 10,
            brakeStrength: 0.8,
            obstacleCount: 3, // Moins d'obstacles
            detectionRange: 15,
            avoidanceStrength: 0.7
        };

        // Initialisation de Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Ciel bleu
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 50);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lumières
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Créer le sol
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(500, 500),
            new THREE.MeshStandardMaterial({ 
                color: 0x228B22, 
                roughness: 0.8, 
                metalness: 0.2 
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Définir le parcours de la route (courbe)
        const roadCurve = new THREE.CurvePath();
        
        // Créer un circuit ovale
        const roadHeight = 0.05;
        const ovalWidth = 70;
        const ovalHeight = 40;
        
        // Créer les points du circuit ovale
        const points = [];
        for (let i = 0; i <= 16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            points.push(new THREE.Vector3(
                ovalWidth * Math.cos(angle),
                roadHeight,
                ovalHeight * Math.sin(angle)
            ));
        }
        
        // Créer une courbe lisse
        const curve = new THREE.CatmullRomCurve3(points);
        curve.closed = true;
        roadCurve.add(curve);
        
        // Créer la route
        const roadPoints = roadCurve.getPoints(500);
        const roadShape = new THREE.Shape();
        roadShape.moveTo(0, -config.roadWidth / 2);
        roadShape.lineTo(0, config.roadWidth / 2);
        
        const extrudeSettings = {
            steps: 500,
            bevelEnabled: false,
            extrudePath: new THREE.CatmullRomCurve3(roadPoints)
        };
        
        // Route
        const road = new THREE.Mesh(
            new THREE.ExtrudeGeometry(roadShape, extrudeSettings),
            new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                roughness: 0.7, 
                metalness: 0.2 
            })
        );
        road.receiveShadow = true;
        scene.add(road);
        
        // Marquage central
        const lineShape = new THREE.Shape();
        lineShape.moveTo(0, -0.2);
        lineShape.lineTo(0, 0.2);
        
        const line = new THREE.Mesh(
            new THREE.ExtrudeGeometry(lineShape, {
                steps: 500,
                bevelEnabled: false,
                extrudePath: new THREE.CatmullRomCurve3(roadPoints)
            }),
            new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
        );
        line.position.y = 0.05;
        scene.add(line);
        
        // Fonction pour créer une voiture
        function createCar(color = 0xFF0000) {
            const carGroup = new THREE.Group();
            
            // Corps de la voiture
            carGroup.add(new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.5, 2),
                new THREE.MeshStandardMaterial({ color: color })
            )).position.set(0, 1, 0);
            
            // Habitacle
            const carTop = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 1.8),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            carTop.position.set(-0.5, 2, 0);
            carGroup.add(carTop);
            
            // Roues
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            [
                { x: 1.5, y: 0.5, z: 1.2 },  // Avant-droit
                { x: 1.5, y: 0.5, z: -1.2 }, // Avant-gauche
                { x: -1.5, y: 0.5, z: 1.2 }, // Arrière-droit
                { x: -1.5, y: 0.5, z: -1.2 } // Arrière-gauche
            ].forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                carGroup.add(wheel);
            });
            
            // Phares
            const headlightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.5
            });
            
            [
                { x: 2, y: 1, z: 0.8 },  // Droit
                { x: 2, y: 1, z: -0.8 }  // Gauche
            ].forEach(pos => {
                const headlight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 16, 16),
                    headlightMaterial
                );
                headlight.position.set(pos.x, pos.y, pos.z);
                carGroup.add(headlight);
                
                // Lumière de phare
                const spotLight = new THREE.SpotLight(0xFFFFAA, 0.8);
                spotLight.position.set(pos.x, pos.y, pos.z);
                spotLight.target.position.set(pos.x + 10, pos.y, pos.z);
                spotLight.angle = 0.3;
                spotLight.penumbra = 0.2;
                spotLight.distance = 30;
                spotLight.castShadow = true;
                carGroup.add(spotLight);
                carGroup.add(spotLight.target);
            });
            
            // Activer les ombres
            carGroup.traverse(obj => {
                if (obj.isMesh) obj.castShadow = true;
            });
            
            return carGroup;
        }
        
        // Liste des types d'obstacles
        const obstacleTypes = [
            {
                name: "Cône",
                create: function() {
                    const group = new THREE.Group();
                    
                    // Base
                    group.add(new THREE.Mesh(
                        new THREE.CylinderGeometry(0.7, 1, 0.3, 16),
                        new THREE.MeshStandardMaterial({ color: 0x222222 })
                    )).position.y = 0.15;
                    
                    // Cône
                    group.add(new THREE.Mesh(
                        new THREE.ConeGeometry(0.5, 1.5, 16),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xFF5500,
                            emissive: 0xFF5500,
                            emissiveIntensity: 0.2
                        })
                    )).position.y = 1;
                    
                    // Bandes réfléchissantes
                    const bandMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFFFFF,
                        emissive: 0xFFFFFF,
                        emissiveIntensity: 0.5
                    });
                    
                    [0.7, 1.1].forEach(y => {
                        const band = new THREE.Mesh(
                            new THREE.TorusGeometry(0.4, 0.05, 8, 16),
                            bandMaterial
                        );
                        band.position.y = y;
                        band.rotation.x = Math.PI / 2;
                        group.add(band);
                    });
                    
                    return group;
                },
                scale: 1.5,
                yOffset: 0
            },
            {
                name: "Rocher",
                create: function() {
                    const geometry = new THREE.DodecahedronGeometry(1, 1);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x888888,
                        roughness: 0.9,
                        metalness: 0.1
                    });
                    
                    // Déformer la géométrie
                    const posAttr = geometry.getAttribute('position');
                    const positions = posAttr.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += (Math.random() - 0.5) * 0.2;
                        positions[i + 1] += (Math.random() - 0.5) * 0.2;
                        positions[i + 2] += (Math.random() - 0.5) * 0.2;
                    }
                    posAttr.needsUpdate = true;
                    
                    return new THREE.Mesh(geometry, material);
                },
                scale: 1.2,
                yOffset: 0.8
            },
            {
                name: "Baril",
                create: function() {
                    const group = new THREE.Group();
                    
                    // Corps du baril
                    group.add(new THREE.Mesh(
                        new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xDD2200,
                            roughness: 0.7
                        })
                    )).position.y = 0.75;
                    
                    // Anneaux
                    const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                    [0.25, 0.75, 1.25].forEach(y => {
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.82, 0.06, 8, 16),
                            ringMaterial
                        );
                        ring.position.y = y;
                        ring.rotation.x = Math.PI / 2;
                        group.add(ring);
                    });
                    
                    return group;
                },
                scale: 1.3,
                yOffset: 0
            }
        ];

        // Fonction pour créer un obstacle
        function createObstacle() {
            // Choisir un type d'obstacle aléatoire
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const obstacle = type.create();
            
            // Appliquer l'échelle et la position
            obstacle.scale.set(type.scale, type.scale, type.scale);
            obstacle.position.y += type.yOffset;
            
            // Ajouter des ombres
            obstacle.traverse(obj => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });
            
            // Ajouter le nom comme propriété
            obstacle.userData = { typeName: type.name };
            
            return obstacle;
        }
        
        // Créer les voitures
        const mainCar = createCar(0xFF0000);
        scene.add(mainCar);
        
        const otherCar = createCar(0x3366FF);
        scene.add(otherCar);
        
        const otherCars = [{
            car: otherCar,
            progress: 0.5, // Position à mi-chemin
            baseSpeed: 0.3,
            currentSpeed: 0.3
        }];
        
        // Créer les obstacles
        const obstacles = [];
        
        // Placer les obstacles à des positions équidistantes
        const obstacleSpacing = 1 / config.obstacleCount;
        for (let i = 0; i < config.obstacleCount; i++) {
            const obstacle = createObstacle();
            scene.add(obstacle);
            
            // Positionner équitablement sur la route, mais pas près du départ
            const progress = 0.1 + (i * obstacleSpacing);
            const point = roadCurve.getPoint(progress);
            const nextPoint = roadCurve.getPoint((progress + 0.01) % 1);
            const direction = new THREE.Vector3().subVectors(nextPoint, point).normalize();
            
            // Positionner sur la voie de droite
            const perpVector = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
            const laneOffset = config.roadWidth / 4;
            
            const obstaclePosition = new THREE.Vector3()
                .copy(point)
                .add(perpVector.multiplyScalar(laneOffset + (Math.random() * 0.4 - 0.2)));
            
            obstacle.position.set(obstaclePosition.x, obstacle.position.y, obstaclePosition.z);
            obstacle.rotation.y = Math.random() * Math.PI * 2;
            
            obstacles.push({
                object: obstacle,
                progress: progress,
                position: obstaclePosition
            });
        }
        
        // Variables de conduite
        let mainCarProgress = 0;
        let mainCarPosition = new THREE.Vector3();
        let mainCarDirection = new THREE.Vector3();
        let mainCarCurrentSpeed = config.carSpeed;
        let isAvoidingObstacle = false;
        let avoidanceOffset = 0;
        let avoidanceDirection = 0;
        let detectedObstacle = null;
        let obstaclePassedTime = 0;
        const SAFETY_MARGIN = 0.03;
        
        // Utilitaires
        function distanceBetweenCurvePoints(progress1, progress2) {
            let distance = Math.abs(progress1 - progress2);
            if (distance > 0.5) distance = 1 - distance;
            return distance * 200; // Facteur approximatif
        }
        
        function isCarAhead(mainProgress, otherProgress) {
            let diff = otherProgress - mainProgress;
            if (diff < -0.5) diff += 1;
            if (diff > 0.5) diff -= 1;
            return diff > 0 && diff < 0.5;
        }
        
        // Fonction pour détecter les obstacles
        function detectObstacles(carProgress, carDirection, laneOffset) {
            const carPoint = roadCurve.getPoint(carProgress);
            
            for (const obstacle of obstacles) {
                const distanceOnCurve = distanceBetweenCurvePoints(carProgress, obstacle.progress);
                
                if (distanceOnCurve < config.detectionRange && isCarAhead(carProgress, obstacle.progress)) {
                    const projectedPoint = roadCurve.getPoint(obstacle.progress);
                    const projectedDirection = new THREE.Vector3()
                        .subVectors(roadCurve.getPoint((obstacle.progress + 0.01) % 1), projectedPoint)
                        .normalize();
                    const projectedPerpVector = new THREE.Vector3(-projectedDirection.z, 0, projectedDirection.x).normalize();
                    const projectedCarPos = new THREE.Vector3()
                        .copy(projectedPoint)
                        .add(projectedPerpVector.multiplyScalar(laneOffset + avoidanceOffset));
                    
                    const lateralDistance = new THREE.Vector3()
                        .subVectors(projectedCarPos, obstacle.position)
                        .length();
                    
                    if (lateralDistance < 2.5) {
                        return {
                            obstacle: obstacle,
                            distance: distanceOnCurve,
                            lateralDistance: lateralDistance
                        };
                    }
                }
            }
            
            return null;
        }
        
        // Mettre en évidence un obstacle
        function highlightObstacle(obstacle) {
            obstacle.traverse(child => {
                if (child.isMesh && child.material) {
                    if (!child.userData.originalMaterial) {
                        child.userData.originalMaterial = child.material.clone();
                    }
                    
                    const highlightMaterial = child.material.clone();
                    highlightMaterial.emissive.set(0x00FF00);
                    highlightMaterial.emissiveIntensity = 0.6;
                    child.material = highlightMaterial;
                }
            });
        }
        
        // Réinitialiser l'apparence d'un obstacle
        function resetObstacleHighlight(obstacle) {
            obstacle.traverse(child => {
                if (child.isMesh && child.material && child.userData.originalMaterial) {
                    child.material = child.userData.originalMaterial;
                    delete child.userData.originalMaterial;
                }
            });
        }
        
        // Fonction d'animation
        function animate() {
            requestAnimationFrame(animate);
            
            // --- Mise à jour de la voiture principale ---
            let targetSpeed = config.carSpeed;
            
            // Vérifier les voitures devant
            for (const otherCar of otherCars) {
                if (isCarAhead(mainCarProgress, otherCar.progress)) {
                    const distance = distanceBetweenCurvePoints(mainCarProgress, otherCar.progress);
                    
                    if (distance < config.safeDistance) {
                        const slowdownFactor = Math.min(distance / config.safeDistance, 1);
                        const possibleTargetSpeed = otherCar.currentSpeed * slowdownFactor;
                        
                        if (possibleTargetSpeed < targetSpeed) {
                            targetSpeed = possibleTargetSpeed;
                        }
                    }
                }
            }
            
            // Appliquer la vitesse progressivement
            if (mainCarCurrentSpeed > targetSpeed) {
                mainCarCurrentSpeed = Math.max(targetSpeed, mainCarCurrentSpeed - config.brakeStrength * 0.01);
            } else {
                mainCarCurrentSpeed = Math.min(targetSpeed, mainCarCurrentSpeed + 0.005);
            }
            
            // Avancer la voiture principale
            mainCarProgress += mainCarCurrentSpeed / 1000;
            if (mainCarProgress > 1) mainCarProgress -= 1;
            
            // Obtenir position et direction
            const point = roadCurve.getPoint(mainCarProgress);
            const nextPoint = roadCurve.getPoint((mainCarProgress + 0.01) % 1);
            mainCarPosition.copy(point);
            mainCarDirection.subVectors(nextPoint, point).normalize();
            
            // Calculer le décalage pour la voie de droite
            const perpVector = new THREE.Vector3(-mainCarDirection.z, 0, mainCarDirection.x).normalize();
            const laneOffset = config.roadWidth / 4;
            
            // Détecter les obstacles
            const obstacleInfo = detectObstacles(mainCarProgress, mainCarDirection, laneOffset);
            const obstacleStatusElement = document.getElementById('obstacleStatus');
            
            // Gérer l'évitement d'obstacles
            if (!isAvoidingObstacle && obstacleInfo) {
                isAvoidingObstacle = true;
                avoidanceDirection = -1; // Toujours éviter vers la gauche
                detectedObstacle = obstacleInfo.obstacle;
                obstaclePassedTime = 0;
                
                if (obstacleStatusElement) {
                    obstacleStatusElement.textContent = `Obstacle détecté : ${detectedObstacle.object.userData.typeName} ! Manœuvre d'évitement...`;
                    obstacleStatusElement.style.color = "#FF3300";
                }
                
                highlightObstacle(detectedObstacle.object);
            } else if (isAvoidingObstacle && detectedObstacle) {
                // Vérifier si l'obstacle est dépassé
                let diff = mainCarProgress - detectedObstacle.progress;
                if (diff < -0.5) diff += 1;
                if (diff > 0.5) diff -= 1;
                
                const hasPassedObstacle = diff > SAFETY_MARGIN;
                
                if (hasPassedObstacle) {
                    obstaclePassedTime += 1/60; // ~delta time
                    
                    if (obstaclePassedTime > 1.0) { // Attendre 1s après dépassement
                        isAvoidingObstacle = false;
                        resetObstacleHighlight(detectedObstacle.object);
                        detectedObstacle = null;
                        
                        if (obstacleStatusElement) {
                            obstacleStatusElement.textContent = "Obstacle évité. Retour à la trajectoire normale.";
                            obstacleStatusElement.style.color = "#33CC33";
                            
                            setTimeout(() => {
                                if (obstacleStatusElement) {
                                    obstacleStatusElement.textContent = "Aucun obstacle détecté.";
                                    obstacleStatusElement.style.color = "#FFFFFF";
                                }
                            }, 3000);
                        }
                    }
                }
            } else if (obstacleStatusElement && obstacleStatusElement.textContent === "") {
                obstacleStatusElement.textContent = "Aucun obstacle détecté.";
                obstacleStatusElement.style.color = "#FFFFFF";
            }
            
            // Mise à jour du décalage d'évitement
            if (isAvoidingObstacle) {
                const maxOffset = config.roadWidth / 3 * avoidanceDirection;
                avoidanceOffset += (maxOffset - avoidanceOffset) * 0.1 * config.avoidanceStrength;
            } else {
                avoidanceOffset *= 0.95; // Retour progressif
            }
            
            // Positionner la voiture principale
            const finalPosition = new THREE.Vector3()
                .copy(point)
                .add(perpVector.clone().multiplyScalar(laneOffset + avoidanceOffset));
            
            mainCar.position.set(finalPosition.x, point.y + 1, finalPosition.z);
            mainCar.rotation.y = -Math.atan2(mainCarDirection.z, mainCarDirection.x);
            
            // --- Mise à jour des autres voitures ---
            for (const otherCar of otherCars) {
                otherCar.progress += otherCar.currentSpeed / 1000;
                if (otherCar.progress > 1) otherCar.progress -= 1;
                
                const otherPoint = roadCurve.getPoint(otherCar.progress);
                const otherNextPoint = roadCurve.getPoint((otherCar.progress + 0.01) % 1);
                const otherDirection = new THREE.Vector3().subVectors(otherNextPoint, otherPoint).normalize();
                const otherPerpVector = new THREE.Vector3(-otherDirection.z, 0, otherDirection.x).normalize();
                
                const otherFinalPosition = new THREE.Vector3()
                    .copy(otherPoint)
                    .add(otherPerpVector.multiplyScalar(laneOffset));
                
                otherCar.car.position.set(otherFinalPosition.x, otherPoint.y + 1, otherFinalPosition.z);
                otherCar.car.rotation.y = -Math.atan2(otherDirection.z, otherDirection.x);
            }
            
            // Caméra qui suit la voiture
            const targetAngle = Math.atan2(mainCarDirection.z, mainCarDirection.x);
            camera.position.set(
                mainCar.position.x - 15 * Math.cos(targetAngle),
                50,
                mainCar.position.z - 15 * Math.sin(targetAngle)
            );
            camera.lookAt(mainCar.position);
            
            // Mettre à jour les informations
            const speedInfo = document.getElementById('speedInfo');
            if (speedInfo) {
                speedInfo.innerHTML = `Vitesse actuelle: ${(mainCarCurrentSpeed/config.carSpeed*100).toFixed(0)}%`;
                
                if (mainCarCurrentSpeed < config.carSpeed * 0.5) {
                    speedInfo.style.color = '#FF0000'; // Rouge - freinage fort
                } else if (mainCarCurrentSpeed < config.carSpeed * 0.8) {
                    speedInfo.style.color = '#FFAA00'; // Orange - ralentissement
                } else {
                    speedInfo.style.color = '#FFFFFF'; // Blanc - vitesse normale
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Gérer le redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Interface de contrôle
        const gui = new dat.GUI();
        gui.add(config, 'carSpeed', 0.1, 2).name('Vitesse max');
        gui.add(config, 'safeDistance', 5, 30).name('Distance de sécurité');
        gui.add(config, 'brakeStrength', 0.1, 1).name('Force de freinage');
        gui.add(config, 'detectionRange', 5, 30).name('Portée détection');
        gui.add(config, 'avoidanceStrength', 0.1, 1).name('Force évitement');
        
        // Démarrer l'animation
        animate();
    </script>
</body>
</html>